<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cavernícola vs Dinosaurios</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <!-- Tone.js library for background music -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #2c3e50; /* Dark blue-gray */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #34495e; /* Slightly lighter blue-gray */
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            padding: 20px;
            max-width: 90vw; /* Responsive width */
            width: 800px; /* Max width */
            box-sizing: border-box;
        }
        canvas {
            background-color: #1a2b3c; /* Even darker blue-gray for game area */
            border: 5px solid #2980b9; /* Blue border */
            border-radius: 10px;
            display: block;
            touch-action: none; /* Disable default touch actions */
        }
        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 10px 0;
            color: #ecf0f1; /* Light text */
            font-size: 1.2em;
            font-weight: bold;
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(44, 62, 80, 0.95); /* Darker overlay */
            border: 3px solid #2980b9;
            border-radius: 10px;
            padding: 30px 40px;
            text-align: center;
            color: #ecf0f1;
            font-size: 1.5em;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            z-index: 100;
            display: none; /* Hidden by default */
        }
        .message-box button {
            background-color: #27ae60; /* Green button */
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 20px;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .message-box button:hover {
            background-color: #2ecc71; /* Lighter green on hover */
            transform: translateY(-2px);
        }
        .message-box button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .controls {
            display: flex;
            gap: 15px;
            margin-top: -20px; /* Reduced margin-top to move controls higher */
        }
        .control-button {
            background-color: #3498db; /* Blue button */
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4); /* More pronounced shadow */
            border: 2px solid #2980b9; /* Add a border */
            background-image: linear-gradient(to bottom right, #3498db, #2980b9); /* Gradient */
        }
        .control-button:hover {
            background-color: #2980b9; /* Darker blue on hover */
            transform: translateY(-3px); /* Lift button slightly */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.6); /* More shadow on hover */
            background-image: linear-gradient(to bottom right, #2980b9, #3498db); /* Reverse gradient on hover */
        }
        .control-button:active {
            transform: translateY(0); /* Press button down */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Smaller shadow on active */
            background-image: linear-gradient(to bottom right, #3498db, #2980b9); /* Original gradient */
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-info">
            <div id="score">Puntuación: 0</div>
            <div id="lives">Vidas: 3</div>
        </div>
        <canvas id="gameCanvas"></canvas>

        <div class="message-box" id="messageBox">
            <p id="messageText"></p>
            <button id="restartButton">Jugar de Nuevo</button>
        </div>

        <div class="controls">
            <div class="control-button" id="leftButton">Izquierda</div>
            <div class="control-button" id="rightButton">Derecha</div>
            <div class="control-button" id="shootButton">Lanzar</div>
            <div class="control-button" id="shieldButton">Escudo</div>
            <!-- Removed music toggle button as music is always on -->
        </div>
    </div>

    <script>
        // Velociraptor properties - moved declaration to the very top
        let velociraptorSpawnInterval = 1000; // Faster spawn for velociraptors

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const shootButton = document.getElementById('shootButton');
        const shieldButton = document.getElementById('shieldButton');
        // Removed musicToggleButton reference

        // Game state variables
        let gameRunning = false;
        let score = 0;
        let lives = 3;

        // Player (Caveman) properties
        const playerWidth = 50;
        const playerHeight = 75;
        let playerX = canvas.width / 2 - playerWidth / 2;
        let playerY = canvas.height - playerHeight - 10;
        const playerSpeed = 2; // Increased player speed slightly
        let playerMovingLeft = false;
        let playerMovingRight = false;
        let hasMultiSpear = false; // Power-up is now permanent
        let isShieldActive = false; // New state for shield activation
        let lastShotTime = 0; // Track time of last shot
        const fireRate = 500; // 0.5 seconds in milliseconds

        // Spears properties
        const spearWidth = 10;
        const spearHeight = 30;
        const spearSpeed = 10;
        let spears = [];

        // Dinosaurs properties
        const dinosaurWidth = 60;
        const dinosaurHeight = 70;
        let dinosaurSpeed = 0.1; // Reduced dinosaur speed
        let dinosaurSpawnInterval = 1000; // milliseconds, can change dynamically
        let dinosaurs = [];
        let lastDinosaurSpawnTime = 0;
        let dinosaurSpawnRateIncreased = false; // Flag to track if spawn rate has increased

        // Velociraptor properties
        const velociraptorWidth = 50;
        const velociraptorHeight = 60;
        const velociraptorSpeed = 0.2; // Reduced velociraptor speed
        let velociraptors = [];
        let lastVelociraptorSpawnTime = 0;
        const velociraptorSpawnScoreThreshold = 100; // Score to start spawning velociraptors

        // Giganotosaurus (regular enemies) properties
        const giganotosaurusWidth = 80;
        const giganotosaurusHeight = 90;
        const giganotosaurusSpeed = 0.05; // Reduced Giganotosaurus speed
        const giganotosaurusSpawnInterval = 1000; // milliseconds, shoots frequently (1 second)
        let giganotosauruses = [];
        let lastGiganotosaurusSpawnTime = 0;
        const regularGiganotosaurusSpawnScoreThreshold = 500; // Score to start spawning regular Giganotosaurus

        // Boss Giganotosaurus properties
        const bossGiganotosaurusWidth = 120; // Larger boss size
        const bossGiganotosaurusHeight = 130;
        const bossStoneRadius = 12; // Larger stones
        const bossHealthMax = 5; // 5 hits to die
        const bossSpawnScoreThreshold = 1000; // Score to trigger boss fight
        const bossShootInterval = 1000; // Slower shooting for boss (1 second)
        let bossActive = false; // Is boss currently active?
        let bossHealth = 0; // Current boss health
        let boss = null; // The boss object
        let isBossFight = false; // Flag to indicate boss fight mode

        // Stones (projectiles) properties
        const stoneRadius = 8; // Default stone radius
        const stoneSpeed = 1; // Reduced stone speed
        let stones = [];
        const dinosaurShootInterval = 1000; // milliseconds (1 second)
        const dinosaurShootChance = 0.45; // 45% probability for dinosaurs to shoot

        // Power-up properties
        const powerUpWidth = 25;
        const powerUpHeight = 25;
        const powerUpSpeed = 3;
        let powerUps = [];
        const powerUpDropChance = 0.05; // 5% chance for a dinosaur to drop a power-up (reduced from 0.2)

        // Game limits - specific per enemy type
        const maxNormalDinosaurs = 5; // Maximum number of normal dinosaurs on screen
        const maxVelociraptors = 5;    // Maximum number of velociraptors on screen
        const maxGiganotosauruses = 5; // Maximum number of giganotosauruses on screen

        // Sound effects (using AudioContext for simple beeps)
        let audioContext;

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSound(type) {
            initAudioContext();
            let oscillator;
            let gainNode = audioContext.createGain();
            gainNode.connect(audioContext.destination);

            switch (type) {
                case 'shoot':
                    oscillator = audioContext.createOscillator();
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                    oscillator.connect(gainNode);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'hit':
                    oscillator = audioContext.createOscillator();
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(220, audioContext.currentTime); // A3
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);
                    oscillator.connect(gainNode);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                case 'gameOver':
                    oscillator = audioContext.createOscillator();
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(100, audioContext.currentTime); // Low frequency
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
                    oscillator.connect(gainNode);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                case 'shield':
                    oscillator = audioContext.createOscillator();
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(660, audioContext.currentTime); // E5
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
                    oscillator.connect(gainNode);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
            }
        }

        // Background Music (Tone.js)
        let synth;
        let loop;

        function initMusic() {
            // Create a simple synth
            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: {
                    type: "triangle"
                },
                envelope: {
                    attack: 0.005,
                    decay: 0.1,
                    sustain: 0.3,
                    release: 1
                }
            }).toDestination();

            // A more varied melodic loop to reduce repetitiveness
            const notes = [
                "C4", "E4", "G4", "A4", "G4", "E4", "C4", // Original phrase
                "D4", "F4", "A4", "B4", "A4", "F4", "D4", // Similar phrase, shifted up
                "E4", "G4", "C5", "B4", "A4", "G4", "E4", // More varied phrase with higher notes
                "C4", "G3", "C4", "E4", "G4", "C5", "G4", "E4" // Arpeggiated and descending
            ];
            let noteIndex = 0;

            loop = new Tone.Loop(time => {
                synth.triggerAttackRelease(notes[noteIndex % notes.length], "8n", time);
                noteIndex++;
            }, "0.5").start(0); // Play every 0.5 seconds

            Tone.Transport.bpm.value = 120; // Set tempo
        }

        // Offscreen canvas for background
        let backgroundCanvas;
        let backgroundCtx;

        // Background drawing function - now accepts context and dimensions
        function drawBackground(ctxToDrawOn, width, height) {
            // Sky - Gradient
            let skyGradient = ctxToDrawOn.createLinearGradient(0, 0, 0, height * 0.7);
            skyGradient.addColorStop(0, '#87CEEB'); // Light Sky Blue
            skyGradient.addColorStop(1, '#6495ED'); // Cornflower Blue
            ctxToDrawOn.fillStyle = skyGradient;
            ctxToDrawOn.fillRect(0, 0, width, height);

            // Ground - Green/Brown mix
            ctxToDrawOn.fillStyle = '#6B8E23'; // Olive Drab
            ctxToDrawOn.fillRect(0, height * 0.7, width, height * 0.3);

            // Distant Trees (darker, less detailed)
            ctxToDrawOn.fillStyle = '#228B22'; // Forest Green
            for (let i = 0; i < 5; i++) {
                let treeX = (i * (width / 5)) + Math.random() * 50;
                let treeHeight = 80 + Math.random() * 40;
                let treeWidth = 40 + Math.random() * 20;
                // Trunk
                ctxToDrawOn.fillRect(treeX, height * 0.7 - treeHeight, treeWidth * 0.3, treeHeight);
                // Canopy (rounded)
                ctxToDrawOn.beginPath();
                ctxToDrawOn.arc(treeX + treeWidth * 0.15, height * 0.7 - treeHeight, treeWidth * 0.6, 0, Math.PI * 2);
                ctxToDrawOn.fill();
            }

            // Closer Trees (lighter, more detailed)
            ctxToDrawOn.fillStyle = '#3CB371'; // Medium Sea Green
            for (let i = 0; i < 4; i++) {
                let treeX = (i * (width / 4)) + Math.random() * 70 - 30;
                let treeHeight = 120 + Math.random() * 60;
                let treeWidth = 60 + Math.random() * 30;
                // Trunk
                ctxToDrawOn.fillStyle = '#8B4513'; // Saddle Brown
                ctxToDrawOn.fillRect(treeX, height * 0.7 - treeHeight, treeWidth * 0.4, treeHeight);
                // Canopy (more irregular)
                ctxToDrawOn.fillStyle = '#3CB371'; // Medium Sea Green
                ctxToDrawOn.beginPath();
                ctxToDrawOn.moveTo(treeX + treeWidth * 0.2, height * 0.7 - treeHeight);
                ctxToDrawOn.lineTo(treeX - treeWidth * 0.1, height * 0.7 - treeHeight * 0.5);
                ctxToDrawOn.lineTo(treeX + treeWidth * 0.2, height * 0.7 - treeHeight * 0.8);
                ctxToDrawOn.lineTo(treeX + treeWidth * 0.7, height * 0.7 - treeHeight * 0.6);
                ctxToDrawOn.lineTo(treeX + treeWidth * 0.4, height * 0.7 - treeHeight);
                ctxToDrawOn.closePath();
                ctxToDrawOn.fill();
            }

            // Bushes/Foliage
            ctxToDrawOn.fillStyle = '#556B2F'; // Dark Olive Green
            for (let i = 0; i < 8; i++) {
                let bushX = (i * (width / 8)) + Math.random() * 40;
                let bushY = height * 0.7 - 20 + Math.random() * 10;
                let bushWidth = 30 + Math.random() * 20;
                let bushHeight = 15 + Math.random() * 10;
                ctxToDrawOn.beginPath();
                ctxToDrawOn.arc(bushX, bushY, bushWidth / 2, 0, Math.PI * 2);
                ctxToDrawOn.fill();
            }
        }

        // Initialize offscreen background canvas
        function initBackgroundCanvas() {
            backgroundCanvas = document.createElement('canvas');
            backgroundCanvas.width = canvas.width;
            backgroundCanvas.height = canvas.height;
            backgroundCtx = backgroundCanvas.getContext('2d');
            // Draw the background once onto the offscreen canvas
            drawBackground(backgroundCtx, backgroundCanvas.width, backgroundCanvas.height);
        }

        // Player drawing (more human-like)
        function drawPlayer() {
            ctx.save(); // Save the current canvas state
            ctx.translate(playerX, playerY); // Translate to player's position

            // Body (more defined torso)
            ctx.fillStyle = '#e67e22'; // Orange-brown for caveman body
            ctx.beginPath();
            ctx.moveTo(playerWidth * 0.2, playerHeight * 0.2);
            ctx.lineTo(playerWidth * 0.8, playerHeight * 0.2);
            ctx.lineTo(playerWidth * 0.9, playerHeight * 0.6);
            ctx.lineTo(playerWidth * 0.1, playerHeight * 0.6);
            ctx.closePath();
            ctx.fill();

            // Loincloth
            ctx.fillStyle = '#a0522d'; // Sienna for loincloth
            ctx.beginPath();
            ctx.moveTo(playerWidth * 0.1, playerHeight * 0.6);
            ctx.lineTo(playerWidth * 0.9, playerHeight * 0.6);
            ctx.lineTo(playerWidth * 0.7, playerHeight * 0.8);
            ctx.lineTo(playerWidth * 0.3, playerHeight * 0.8);
            ctx.closePath();
            ctx.fill();

            // Head (more oval)
            ctx.fillStyle = '#f1c40f'; // Yellow for head
            ctx.beginPath();
            ctx.ellipse(playerWidth / 2, playerHeight * 0.1, playerWidth * 0.2, playerHeight * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();

            // Hair (bushy)
            ctx.fillStyle = '#8B4513'; // Saddle Brown for hair
            ctx.beginPath();
            ctx.arc(playerWidth / 2, playerHeight * 0.05, playerWidth * 0.25, Math.PI, 0, false);
            ctx.fill();

            // Eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(playerWidth * 0.4, playerHeight * 0.08, 2, 0, Math.PI * 2); // Left eye
            ctx.arc(playerWidth * 0.6, playerHeight * 0.08, 2, 0, Math.PI * 2); // Right eye
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(playerWidth * 0.4, playerHeight * 0.08, 1, 0, Math.PI * 2); // Left pupil
            ctx.arc(playerWidth * 0.6, playerHeight * 0.08, 1, 0, Math.PI * 2); // Right pupil
            ctx.fill();

            // Mouth
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(playerWidth / 2, playerHeight * 0.12, 5, 0, Math.PI, false); // Simple curved mouth
            ctx.stroke();

            // Arms (more defined, holding spear)
            ctx.fillStyle = '#f1c40f'; // Skin color for arms
            ctx.fillRect(playerWidth * 0.15, playerHeight * 0.3, playerWidth * 0.1, playerHeight * 0.3); // Left arm
            ctx.fillRect(playerWidth * 0.75, playerHeight * 0.3, playerWidth * 0.1, playerHeight * 0.3); // Right arm

            // Legs (more defined)
            ctx.fillRect(playerWidth * 0.2, playerHeight * 0.65, playerWidth * 0.15, playerHeight * 0.35); // Left leg
            ctx.fillRect(playerWidth * 0.65, playerHeight * 0.65, playerWidth * 0.15, playerHeight * 0.35); // Right leg

            // Spear in hand (visual only)
            ctx.fillStyle = '#bdc3c7'; // Gray for spear shaft
            ctx.fillRect(playerWidth / 2 - 2, -15, 4, 45); // Adjusted Y for spear
            ctx.fillStyle = '#c0392b'; // Red for spear tip
            ctx.beginPath();
            ctx.moveTo(playerWidth / 2, -15);
            ctx.lineTo(playerWidth / 2 - 7, -30);
            ctx.lineTo(playerWidth / 2 + 7, -30);
            ctx.closePath();
            ctx.fill();

            ctx.restore(); // Restore the canvas state
        }

        // Spear drawing
        function drawSpear(spear) {
            ctx.fillStyle = '#bdc3c7'; // Gray for spear shaft
            ctx.fillRect(spear.x, spear.y, spearWidth, spearHeight);
            ctx.fillStyle = '#c0392b'; // Red for spear tip
            ctx.beginPath();
            ctx.moveTo(spear.x + spearWidth / 2, spear.y);
            ctx.lineTo(spear.x + spearWidth / 2 - 5, spear.y - 15);
            ctx.lineTo(spear.x + spearWidth / 2 + 5, spear.y - 15);
            ctx.closePath();
            ctx.fill();
        }

        // Dinosaur drawing (more realistic)
        function drawDinosaur(dinosaur) {
            ctx.save();
            ctx.translate(dinosaur.x, dinosaur.y);

            // Body (rounded rectangle)
            ctx.fillStyle = '#2ecc71'; // Green for dinosaur body
            ctx.beginPath();
            ctx.roundRect(0, dinosaurHeight * 0.2, dinosaurWidth, dinosaurHeight * 0.8, 15); // Rounded body
            ctx.fill();

            // Neck
            ctx.beginPath();
            ctx.moveTo(dinosaurWidth * 0.7, dinosaurHeight * 0.2);
            ctx.lineTo(dinosaurWidth * 0.8, dinosaurHeight * 0.05);
            ctx.lineTo(dinosaurWidth * 0.9, dinosaurHeight * 0.05);
            ctx.lineTo(dinosaurWidth * 0.9, dinosaurHeight * 0.2);
            ctx.closePath();
            ctx.fill();

            // Head
            ctx.fillStyle = '#27ae60'; // Darker green
            ctx.beginPath();
            ctx.arc(dinosaurWidth * 0.85, dinosaurHeight * 0.05, 15, 0, Math.PI * 2);
            ctx.fill();

            // Tail
            ctx.beginPath();
            ctx.moveTo(0, dinosaurHeight * 0.8);
            ctx.lineTo(-20, dinosaurHeight * 0.7);
            ctx.lineTo(-10, dinosaurHeight * 0.9);
            ctx.closePath();
            ctx.fill();

            // Spikes (simple triangles)
            ctx.fillStyle = '#c0392b'; // Red spikes
            ctx.beginPath();
            ctx.moveTo(dinosaurWidth * 0.2, dinosaurHeight * 0.2);
            ctx.lineTo(dinosaurWidth * 0.25, dinosaurHeight * 0.1);
            ctx.lineTo(dinosaurWidth * 0.3, dinosaurHeight * 0.2);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(dinosaurWidth * 0.4, dinosaurHeight * 0.2);
            ctx.lineTo(dinosaurWidth * 0.45, dinosaurHeight * 0.1);
            ctx.lineTo(dinosaurWidth * 0.5, dinosaurHeight * 0.2);
            ctx.fill();

            // Legs
            ctx.fillStyle = '#27ae60'; // Darker green for legs
            ctx.fillRect(dinosaurWidth * 0.2, dinosaurHeight * 0.8, 15, 25); // Front leg
            ctx.fillRect(dinosaurWidth * 0.6, dinosaurHeight * 0.8, 15, 25); // Back leg

            // Eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(dinosaurWidth * 0.8, dinosaurHeight * 0.03, 3, 0, Math.PI * 2); // Left eye
            ctx.arc(dinosaurWidth * 0.9, dinosaurHeight * 0.03, 3, 0, Math.PI * 2); // Right eye
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(dinosaurWidth * 0.8, dinosaurHeight * 0.03, 1, 0, Math.PI * 2); // Left pupil
            ctx.arc(dinosaurWidth * 0.9, dinosaurHeight * 0.03, 1, 0, Math.PI * 2); // Right pupil
            ctx.fill();

            // Mouth
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(dinosaurWidth * 0.85, dinosaurHeight * 0.1, 8, 0, Math.PI, false); // Simple curved mouth
            ctx.stroke();

            ctx.restore();
        }

        // Velociraptor drawing (more realistic)
        function drawVelociraptor(velociraptor) {
            ctx.save();
            ctx.translate(velociraptor.x, velociraptor.y);

            // Body (leaner, more curved)
            ctx.fillStyle = '#a0522d'; // Brown for velociraptor body
            ctx.beginPath();
            ctx.moveTo(velociraptorWidth * 0.1, velociraptorHeight * 0.3);
            ctx.lineTo(velociraptorWidth * 0.9, velociraptorHeight * 0.2);
            ctx.lineTo(velociraptorWidth * 0.8, velociraptorHeight * 0.9);
            ctx.lineTo(velociraptorWidth * 0.2, velociraptorHeight * 0.9);
            ctx.closePath();
            ctx.fill();

            // Neck (thin)
            ctx.beginPath();
            ctx.moveTo(velociraptorWidth * 0.7, velociraptorHeight * 0.2);
            ctx.lineTo(velociraptorWidth * 0.75, velociraptorHeight * 0.05);
            ctx.lineTo(velociraptorWidth * 0.8, velociraptorHeight * 0.05);
            ctx.lineTo(velociraptorWidth * 0.85, velociraptorHeight * 0.2);
            ctx.closePath();
            ctx.fill();

            // Head (pointed)
            ctx.fillStyle = '#8b4513'; // Darker brown
            ctx.beginPath();
            ctx.moveTo(velociraptorWidth * 0.75, velociraptorHeight * 0.05);
            ctx.lineTo(velociraptorWidth * 0.95, velociraptorHeight * 0.08);
            ctx.lineTo(velociraptorWidth * 0.75, velociraptorHeight * 0.15);
            ctx.closePath();
            ctx.fill();

            // Tail (long and thin)
            ctx.beginPath();
            ctx.moveTo(velociraptorWidth * 0.1, velociraptorHeight * 0.8);
            ctx.lineTo(-25, velociraptorHeight * 0.7);
            ctx.lineTo(-15, velociraptorHeight * 0.9);
            ctx.closePath();
            ctx.fill();

            // Legs (strong, bent)
            ctx.fillStyle = '#8b4513'; // Darker brown for legs
            ctx.beginPath();
            ctx.moveTo(velociraptorWidth * 0.3, velociraptorHeight * 0.9);
            ctx.lineTo(velociraptorWidth * 0.35, velociraptorHeight * 0.7);
            ctx.lineTo(velociraptorWidth * 0.4, velociraptorHeight);
            ctx.lineTo(velociraptorWidth * 0.25, velociraptorHeight);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(velociraptorWidth * 0.6, velociraptorHeight * 0.9);
            ctx.lineTo(velociraptorWidth * 0.65, velociraptorHeight * 0.7);
            ctx.lineTo(velociraptorWidth * 0.7, velociraptorHeight);
            ctx.lineTo(velociraptorWidth * 0.55, velociraptorHeight);
            ctx.closePath();
            ctx.fill();

            // Eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(velociraptorWidth * 0.8, velociraptorHeight * 0.06, 2, 0, Math.PI * 2); // Eye
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(velociraptorWidth * 0.8, velociraptorHeight * 0.06, 1, 0, Math.PI * 2); // Pupil
            ctx.fill();

            // Mouth (thin line)
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(velociraptorWidth * 0.78, velociraptorHeight * 0.1);
            ctx.lineTo(velociraptorWidth * 0.9, velociraptorHeight * 0.1);
            ctx.stroke();

            ctx.restore();
        }

        // Giganotosaurus drawing (larger, more menacing)
        function drawGiganotosaurus(giganotosaurus) {
            ctx.save();
            ctx.translate(giganotosaurus.x, giganotosaurus.y);

            // Body (massive)
            ctx.fillStyle = '#5a5a5a'; // Dark grey for giganotosaurus body
            ctx.beginPath();
            ctx.roundRect(0, giganotosaurusHeight * 0.3, giganotosaurusWidth, giganotosaurusHeight * 0.7, 20);
            ctx.fill();

            // Neck (thick)
            ctx.beginPath();
            ctx.moveTo(giganotosaurusWidth * 0.7, giganotosaurusHeight * 0.3);
            ctx.lineTo(giganotosaurusWidth * 0.8, giganotosaurusHeight * 0.1);
            ctx.lineTo(giganotosaurusWidth * 0.9, giganotosaurusHeight * 0.1);
            ctx.lineTo(giganotosaurusWidth, giganotosaurusHeight * 0.3);
            ctx.closePath();
            ctx.fill();

            // Head (large, blocky)
            ctx.fillStyle = '#4a4a4a'; // Even darker grey
            ctx.beginPath();
            ctx.moveTo(giganotosaurusWidth * 0.8, giganotosaurusHeight * 0.1);
            ctx.lineTo(giganotosaurusWidth * 0.95, giganotosaurusHeight * 0.05);
            ctx.lineTo(giganotosaurusWidth * 1.05, giganotosaurusHeight * 0.15);
            ctx.lineTo(giganotosaurusWidth * 0.9, giganotosaurusHeight * 0.25);
            ctx.closePath();
            ctx.fill();

            // Tail (thick, powerful)
            ctx.beginPath();
            ctx.moveTo(0, giganotosaurusHeight * 0.8);
            ctx.lineTo(-30, giganotosaurusHeight * 0.7);
            ctx.lineTo(-10, giganotosaurusHeight);
            ctx.closePath();
            ctx.fill();

            // Spikes (large, jagged)
            ctx.fillStyle = '#c0392b'; // Red spikes
            ctx.beginPath();
            ctx.moveTo(giganotosaurusWidth * 0.3, giganotosaurusHeight * 0.3);
            ctx.lineTo(giganotosaurusWidth * 0.35, giganotosaurusHeight * 0.2);
            ctx.lineTo(giganotosaurusWidth * 0.4, giganotosaurusHeight * 0.3);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(giganotosaurusWidth * 0.5, giganotosaurusHeight * 0.3);
            ctx.lineTo(giganotosaurusWidth * 0.55, giganotosaurusHeight * 0.2);
            ctx.lineTo(giganotosaurusWidth * 0.6, giganotosaurusHeight * 0.3);
            ctx.fill();

            // Legs (very thick)
            ctx.fillStyle = '#4a4a4a'; // Darker grey for legs
            ctx.fillRect(giganotosaurusWidth * 0.2, giganotosaurusHeight * 0.8, 20, 30); // Front leg
            ctx.fillRect(giganotosaurusWidth * 0.6, giganotosaurusHeight * 0.8, 20, 30); // Back leg

            // Eyes (red, menacing)
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(giganotosaurusWidth * 0.88, giganotosaurusHeight * 0.08, 4, 0, Math.PI * 2); // Eye
            ctx.fill();

            // Mouth (jagged for teeth)
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(giganotosaurusWidth * 0.85, giganotosaurusHeight * 0.15);
            ctx.lineTo(giganotosaurusWidth * 0.95, giganotosaurusHeight * 0.15);
            ctx.lineTo(giganotosaurusWidth * 0.9, giganotosaurusHeight * 0.2);
            ctx.closePath();
            ctx.stroke();

            ctx.restore();
        }

        // Boss Giganotosaurus drawing (even larger, more detailed)
        function drawBossGiganotosaurus(boss) {
            ctx.save();
            ctx.translate(boss.x, boss.y);

            // Body (massive, with some texture)
            ctx.fillStyle = '#8b0000'; // Dark red for boss body
            ctx.beginPath();
            ctx.roundRect(0, boss.height * 0.3, boss.width, boss.height * 0.7, 25);
            ctx.fill();

            // Neck (very thick)
            ctx.fillStyle = '#660000'; // Even darker red
            ctx.beginPath();
            ctx.moveTo(boss.width * 0.7, boss.height * 0.3);
            ctx.lineTo(boss.width * 0.8, boss.height * 0.1);
            ctx.lineTo(boss.width * 0.9, boss.height * 0.1);
            ctx.lineTo(boss.width, boss.height * 0.3);
            ctx.closePath();
            ctx.fill();

            // Head (huge, detailed)
            ctx.fillStyle = '#660000'; // Even darker red
            ctx.beginPath();
            ctx.moveTo(boss.width * 0.8, boss.height * 0.1);
            ctx.lineTo(boss.width * 0.98, boss.height * 0.05);
            ctx.lineTo(boss.width * 1.08, boss.height * 0.15);
            ctx.lineTo(boss.width * 0.95, boss.height * 0.28);
            ctx.closePath();
            ctx.fill();

            // Tail (massive, with segments)
            ctx.fillStyle = '#8b0000';
            ctx.beginPath();
            ctx.moveTo(0, boss.height * 0.8);
            ctx.lineTo(-40, boss.height * 0.7);
            ctx.lineTo(-20, boss.height);
            ctx.closePath();
            ctx.fill();
            // Tail segments (simple lines)
            ctx.strokeStyle = '#4a0000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-10, boss.height * 0.85);
            ctx.lineTo(boss.width * 0.1, boss.height * 0.7);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-5, boss.height * 0.9);
            ctx.lineTo(boss.width * 0.05, boss.height * 0.8);
            ctx.stroke();


            // Spikes (very large, prominent)
            ctx.fillStyle = '#ff4500'; // Orange-red spikes
            ctx.beginPath();
            ctx.moveTo(boss.width * 0.3, boss.height * 0.3);
            ctx.lineTo(boss.width * 0.35, boss.height * 0.15);
            ctx.lineTo(boss.width * 0.4, boss.height * 0.3);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(boss.width * 0.5, boss.height * 0.3);
            ctx.lineTo(boss.width * 0.55, boss.height * 0.15);
            ctx.lineTo(boss.width * 0.6, boss.height * 0.3);
            ctx.fill();

            // Legs (colossal)
            ctx.fillStyle = '#660000'; // Darker red for legs
            ctx.fillRect(boss.width * 0.2, boss.height * 0.8, 30, 40); // Front leg
            ctx.fillRect(boss.width * 0.6, boss.height * 0.8, 30, 40); // Back leg

            // Eyes (glowing yellow)
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.arc(boss.width * 0.92, boss.height * 0.08, 6, 0, Math.PI * 2); // Eye
            ctx.fill();

            // Mouth (jagged with teeth)
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(boss.width * 0.88, boss.height * 0.18);
            ctx.lineTo(boss.width * 1.02, boss.height * 0.18);
            ctx.lineTo(boss.width * 0.95, boss.height * 0.25);
            ctx.closePath();
            ctx.stroke();
            // Teeth (simple triangles)
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(boss.width * 0.89, boss.height * 0.18);
            ctx.lineTo(boss.width * 0.9, boss.height * 0.22);
            ctx.lineTo(boss.width * 0.91, boss.height * 0.18);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(boss.width * 0.93, boss.height * 0.18);
            ctx.lineTo(boss.width * 0.94, boss.height * 0.22);
            ctx.lineTo(boss.width * 0.95, boss.height * 0.18);
            ctx.fill();


            // Health bar for the boss
            const healthBarWidth = boss.width * 0.8;
            const healthBarHeight = 10;
            const healthBarX = (boss.width - healthBarWidth) / 2;
            const healthBarY = -30;

            ctx.fillStyle = 'red';
            ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

            ctx.fillStyle = 'lime'; // Green for remaining health
            const currentHealthWidth = (bossHealth / bossHealthMax) * healthBarWidth;
            ctx.fillRect(healthBarX, healthBarY, currentHealthWidth, healthBarHeight);

            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

            ctx.restore();
        }

        // Stone drawing
        function drawStone(stone) {
            ctx.fillStyle = '#95a5a6'; // Gray for stone
            ctx.beginPath();
            ctx.arc(stone.x, stone.y, stone.radius, 0, Math.PI * 2); // Use stone.radius
            ctx.fill();
        }

        // Power-up drawing
        function drawPowerUp(powerUp) {
            ctx.fillStyle = '#f39c12'; // Orange for power-up
            ctx.fillRect(powerUp.x, powerUp.y, powerUpWidth, powerUpHeight);
            // Add a simple icon for multi-spear (e.g., three small triangles)
            if (powerUp.type === 'multi-spear') {
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.moveTo(powerUp.x + powerUpWidth * 0.2, powerUp.y + powerUpHeight * 0.8);
                ctx.lineTo(powerUp.x + powerUpWidth * 0.3, powerUp.y + powerUpHeight * 0.2);
                ctx.lineTo(powerUp.x + powerUpWidth * 0.4, powerUp.y + powerUpHeight * 0.8);
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(powerUp.x + powerUpWidth * 0.4, powerUp.y + powerUpHeight * 0.8);
                ctx.lineTo(powerUp.x + powerUpWidth * 0.5, powerUp.y + powerUpHeight * 0.2);
                ctx.lineTo(powerUp.x + powerUpWidth * 0.6, powerUp.y + powerUpHeight * 0.8);
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(powerUp.x + powerUpWidth * 0.6, powerUp.y + powerUpHeight * 0.8);
                ctx.lineTo(powerUp.x + powerUpWidth * 0.7, powerUp.y + powerUpHeight * 0.2);
                ctx.lineTo(powerUp.x + powerUpWidth * 0.8, powerUp.y + powerUpHeight * 0.8);
                ctx.fill();
            }
        }

        // Shield drawing
        function drawShield() {
            if (isShieldActive) {
                ctx.fillStyle = 'rgba(100, 150, 255, 0.5)'; // Translucent blue
                ctx.beginPath();
                // Draw a circle around the player
                ctx.arc(playerX + playerWidth / 2, playerY + playerHeight / 2, playerWidth * 0.8, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'rgba(100, 150, 255, 0.8)'; // More opaque blue border
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        // Helper function for enemy-to-enemy collision (stacking)
        function checkOverlapAndStack(movingEnemy, movingWidth, movingHeight, staticEnemy, staticWidth, staticHeight, proposedMovingY) {
            // Horizontal overlap
            const horizontalOverlap = (
                movingEnemy.x < staticEnemy.x + staticWidth &&
                movingEnemy.x + movingWidth > staticEnemy.x
            );

            // Vertical collision: movingEnemy's proposed bottom would pass staticEnemy's top,
            // AND movingEnemy's current bottom is above or at staticEnemy's top.
            const verticalCollision = (
                proposedMovingY + movingHeight > staticEnemy.y &&
                movingEnemy.y + movingHeight <= staticEnemy.y
            );

            return horizontalOverlap && verticalCollision;
        }

        // Resize canvas function
        function resizeCanvas() {
            canvas.width = Math.min(window.innerWidth * 0.7, 800); // Reduced width
            canvas.height = Math.min(window.innerHeight * 0.6, 600); // Reduced height
            playerX = canvas.width / 2 - playerWidth / 2;
            playerY = canvas.height - playerHeight - 10;
            // Always re-initialize and redraw the background canvas on resize
            initBackgroundCanvas();
            draw(); // Redraw game elements
        }

        // Initial resize and event listener for window resize
        window.addEventListener('resize', resizeCanvas);
        // The initial call to resizeCanvas() is now handled in window.onload

        // Update game logic
        function update() {
            if (!gameRunning) return;

            // Player movement
            if (playerMovingLeft && playerX > 0) {
                playerX -= playerSpeed;
            }
            if (playerMovingRight && playerX + playerWidth < canvas.width) {
                playerX += playerSpeed;
            }

            // Update spears
            for (let i = spears.length - 1; i >= 0; i--) {
                spears[i].y -= spearSpeed;
                if (spears[i].y < 0) {
                    spears.splice(i, 1); // Remove if off-screen
                }
            }

            const currentTime = Date.now();

            // Boss spawn logic
            if (score >= bossSpawnScoreThreshold && !bossActive && !isBossFight) {
                isBossFight = true; // Activate boss fight mode
                bossActive = true;
                bossHealth = bossHealthMax; // Set boss health
                // Spawn boss in the middle top, stationary
                boss = {
                    x: canvas.width / 2 - bossGiganotosaurusWidth / 2,
                    y: 50, // Fixed Y position
                    lastShotTime: currentTime,
                    width: bossGiganotosaurusWidth,
                    height: bossGiganotosaurusHeight
                };
                // Clear existing enemies and projectiles for boss fight focus
                dinosaurs = [];
                velociraptors = [];
                giganotosauruses = [];
                powerUps = [];
                stones = [];
            }

            // Handle boss logic if active
            if (bossActive) {
                // Boss shooting (3 larger stones at once)
                if (currentTime - boss.lastShotTime > bossShootInterval) {
                    if (Math.random() < dinosaurShootChance) { // Apply probability to boss shot
                        stones.push({ x: boss.x + boss.width / 2, y: boss.y + boss.height, radius: bossStoneRadius }); // Middle
                        stones.push({ x: boss.x + boss.width / 2 - 25, y: boss.y + boss.height, radius: bossStoneRadius }); // Left
                        stones.push({ x: boss.x + boss.width / 2 + 25, y: boss.y + boss.height, radius: bossStoneRadius }); // Right
                    }
                    boss.lastShotTime = currentTime;
                }
                // Boss does not move, so no position update
            } else { // Only spawn other enemies if boss is not active

                // Spawn dinosaurs (normal)
                if (dinosaurs.length < maxNormalDinosaurs && currentTime - lastDinosaurSpawnTime > dinosaurSpawnInterval) {
                    const x = Math.random() * (canvas.width - dinosaurWidth);
                    dinosaurs.push({ x: x, y: 0, lastShotTime: currentTime, type: 'dinosaur' });
                    lastDinosaurSpawnTime = currentTime;
                }

                // Spawn Velociraptors if score threshold is met
                if (velociraptors.length < maxVelociraptors && score >= velociraptorSpawnScoreThreshold && currentTime - lastVelociraptorSpawnTime > velociraptorSpawnInterval) {
                    const x = Math.random() * (canvas.width - velociraptorWidth);
                    velociraptors.push({ x: x, y: 0, type: 'velociraptor' }); // Removed lastShotTime for velociraptors
                    lastVelociraptorSpawnTime = currentTime;
                }

                // Spawn regular Giganotosaurus if score threshold is met
                if (giganotosauruses.length < maxGiganotosauruses && score >= regularGiganotosaurusSpawnScoreThreshold && currentTime - lastGiganotosaurusSpawnTime > giganotosaurusSpawnInterval) {
                    const x = Math.random() * (canvas.width - giganotosaurusWidth);
                    giganotosauruses.push({ x: x, y: 0, lastShotTime: currentTime, type: 'giganotosaurus' }); // Regular Giganotosaurus shoots
                    lastGiganotosaurusSpawnTime = currentTime;
                }
            }

            // Combine all enemies for collision checking among themselves
            let allEnemiesForCollision = [
                ...dinosaurs.map(d => ({ ...d, width: dinosaurWidth, height: dinosaurHeight })),
                ...velociraptors.map(v => ({ ...v, width: velociraptorWidth, height: velociraptorHeight })),
                ...giganotosauruses.map(g => ({ ...g, width: giganotosaurusWidth, height: giganotosaurusHeight }))
            ];


            // Update dinosaurs and make them shoot
            for (let i = dinosaurs.length - 1; i >= 0; i--) {
                let currentDino = dinosaurs[i];
                let proposedY = currentDino.y + dinosaurSpeed;
                let finalY = proposedY;

                // Check collision with other enemies (including other types)
                for (let j = 0; j < allEnemiesForCollision.length; j++) {
                    let otherEnemy = allEnemiesForCollision[j];
                    if (currentDino === otherEnemy) continue; // Don't check against itself

                    if (checkOverlapAndStack(currentDino, dinosaurWidth, dinosaurHeight, otherEnemy, otherEnemy.width, otherEnemy.height, proposedY)) {
                        finalY = Math.min(finalY, otherEnemy.y - dinosaurHeight); // Stop just above otherEnemy
                    }
                }
                currentDino.y = finalY;

                // Dinosaur shooting
                if (currentTime - currentDino.lastShotTime > dinosaurShootInterval) {
                    if (Math.random() < dinosaurShootChance) { // Apply probability
                        stones.push({ x: currentDino.x + dinosaurWidth / 2, y: currentDino.y + dinosaurHeight, radius: stoneRadius });
                    }
                    currentDino.lastShotTime = currentTime;
                }

                if (currentDino.y + dinosaurHeight > canvas.height) {
                    // Dinosaur reached bottom, game over
                    endGame("¡Un dinosaurio ha llegado al final! ¡Fin del juego!");
                    return;
                }
            }

            // Update velociraptors (no shooting logic here)
            for (let i = velociraptors.length - 1; i >= 0; i--) {
                let currentVelociraptor = velociraptors[i];
                let proposedY = currentVelociraptor.y + velociraptorSpeed;
                let finalY = proposedY;

                // Check collision with other enemies
                for (let j = 0; j < allEnemiesForCollision.length; j++) {
                    let otherEnemy = allEnemiesForCollision[j];
                    if (currentVelociraptor === otherEnemy) continue;

                    if (checkOverlapAndStack(currentVelociraptor, velociraptorWidth, velociraptorHeight, otherEnemy, otherEnemy.width, otherEnemy.height, proposedY)) {
                        finalY = Math.min(finalY, otherEnemy.y - velociraptorHeight);
                    }
                }
                currentVelociraptor.y = finalY;

                if (currentVelociraptor.y + velociraptorHeight > canvas.height) {
                    // Velociraptor reached bottom, game over
                    endGame("¡Un velociraptor ha llegado al final! ¡Fin del juego!");
                    return;
                }
            }

            // Update regular giganotosauruses and make them shoot
            for (let i = giganotosauruses.length - 1; i >= 0; i--) {
                let currentGiganotosaurus = giganotosauruses[i];
                let proposedY = currentGiganotosaurus.y + giganotosaurusSpeed;
                let finalY = proposedY;

                // Check collision with other enemies
                for (let j = 0; j < allEnemiesForCollision.length; j++) {
                    let otherEnemy = allEnemiesForCollision[j];
                    if (currentGiganotosaurus === otherEnemy) continue;

                    if (checkOverlapAndStack(currentGiganotosaurus, giganotosaurusWidth, giganotosaurusHeight, otherEnemy, otherEnemy.width, otherEnemy.height, proposedY)) {
                        finalY = Math.min(finalY, otherEnemy.y - giganotosaurusHeight);
                    }
                }
                currentGiganotosaurus.y = finalY;

                // Regular Giganotosaurus shooting (3 stones at once)
                if (currentTime - currentGiganotosaurus.lastShotTime > dinosaurShootInterval) {
                    if (Math.random() < dinosaurShootChance) { // Apply probability
                        stones.push({ x: currentGiganotosaurus.x + giganotosaurusWidth / 2, y: currentGiganotosaurus.y + giganotosaurusHeight, radius: stoneRadius }); // Middle
                        stones.push({ x: currentGiganotosaurus.x + giganotosaurusWidth / 2 - 15, y: currentGiganotosaurus.y + giganotosaurusHeight, radius: stoneRadius }); // Left
                        stones.push({ x: currentGiganotosaurus.x + giganotosaurusWidth / 2 + 15, y: currentGiganotosaurus.y + giganotosaurusHeight, radius: stoneRadius }); // Right
                    }
                    currentGiganotosaurus.lastShotTime = currentTime;
                }

                if (currentGiganotosaurus.y + giganotosaurusHeight > canvas.height) {
                    // Giganotosaurus reached bottom, game over
                    endGame("¡Un Giganotosaurio ha llegado al final! ¡Fin del juego!");
                    return;
                }
            }

            // Update stones
            for (let i = stones.length - 1; i >= 0; i--) {
                stones[i].y += stoneSpeed;
                if (stones[i].y > canvas.height) {
                    stones.splice(i, 1); // Remove if off-screen
                }
            }

            // Update power-ups
            for (let i = powerUps.length - 1; i >= 0; i--) {
                powerUps[i].y += powerUpSpeed;
                if (powerUps[i].y > canvas.height) {
                    powerUps.splice(i, 1); // Remove if off-screen
                }
            }

            // Collision detection: Spear vs Dinosaur
            for (let i = spears.length - 1; i >= 0; i--) {
                for (let j = dinosaurs.length - 1; j >= 0; j--) {
                    if (
                        spears[i].x < dinosaurs[j].x + dinosaurWidth &&
                        spears[i].x + spearWidth > dinosaurs[j].x &&
                        spears[i].y < dinosaurs[j].y + dinosaurHeight &&
                        spears[i].y + spearHeight > dinosaurs[j].y
                    ) {
                        // Collision! Remove spear and dinosaur
                        spears.splice(i, 1);
                        const defeatedDinosaur = dinosaurs.splice(j, 1)[0];
                        score += 10; // Increase score
                        scoreDisplay.textContent = `Puntuación: ${score}`;
                        playSound('hit'); // Play hit sound
                        // Randomly drop a power-up
                        if (Math.random() < powerUpDropChance) {
                            powerUps.push({
                                x: defeatedDinosaur.x + dinosaurWidth / 2 - powerUpWidth / 2,
                                y: defeatedDinosaur.y + dinosaurHeight / 2,
                                type: 'multi-spear' // Currently only one type
                            });
                        }
                        break; // Break inner loop as spear is removed
                    }
                }
            }

            // Collision detection: Spear vs Velociraptor
            for (let i = spears.length - 1; i >= 0; i--) {
                for (let j = velociraptors.length - 1; j >= 0; j--) {
                    if (
                        spears[i].x < velociraptors[j].x + velociraptorWidth &&
                        spears[i].x + spearWidth > velociraptors[j].x &&
                        spears[i].y < velociraptors[j].y + velociraptorHeight &&
                        spears[i].y + spearHeight > velociraptors[j].y
                    ) {
                        // Collision! Remove spear and velociraptor
                        spears.splice(i, 1);
                        velociraptors.splice(j, 1);
                        score += 15; // Velociraptors give more points
                        scoreDisplay.textContent = `Puntuación: ${score}`;
                        playSound('hit'); // Play hit sound
                        break; // Break inner loop as spear is removed
                    }
                }
            }

            // Collision detection: Spear vs Regular Giganotosaurus
            for (let i = spears.length - 1; i >= 0; i--) {
                for (let j = giganotosauruses.length - 1; j >= 0; j--) {
                    if (
                        spears[i].x < giganotosauruses[j].x + giganotosaurusWidth &&
                        spears[i].x + spearWidth > giganotosauruses[j].x &&
                        spears[i].y < giganotosauruses[j].y + giganotosaurusHeight &&
                        spears[i].y + spearHeight > giganotosauruses[j].y
                    ) {
                        // Collision! Remove spear and regular giganotosaurus
                        spears.splice(i, 1);
                        giganotosauruses.splice(j, 1);
                        score += 50; // Regular Giganotosaurus gives significantly more points
                        scoreDisplay.textContent = `Puntuación: ${score}`;
                        playSound('hit'); // Play hit sound
                        break; // Break inner loop as spear is removed
                    }
                }
            }

            // Collision detection: Spear vs Boss Giganotosaurus
            if (bossActive) {
                for (let i = spears.length - 1; i >= 0; i--) {
                    if (
                        spears[i].x < boss.x + boss.width &&
                        spears[i].x + spearWidth > boss.x &&
                        spears[i].y < boss.y + boss.height &&
                        spears[i].y + spearHeight > boss.y
                    ) {
                        spears.splice(i, 1); // Remove spear
                        bossHealth--; // Decrease boss health
                        playSound('hit'); // Play hit sound
                        if (bossHealth <= 0) {
                            // Boss defeated!
                            bossActive = false;
                            isBossFight = false; // End boss fight mode
                            score += 200; // Bonus points for defeating boss
                            scoreDisplay.textContent = `Puntuación: ${score}`;
                            messageText.textContent = "¡Has derrotado al Giganotosaurio Jefe!";
                            messageBox.style.display = 'block';
                            // Resume normal enemy spawning, possibly with increased difficulty
                            dinosaurSpawnRateIncreased = false; // Reset to allow re-triggering if needed
                            dinosaurSpawnInterval = 1000; // Make normal dinosaurs faster after boss
                            velociraptorSpawnInterval = 1000; // Make velociraptors faster
                        }
                        break; // Break inner loop as spear is removed
                    }
                }
            }

            // Collision detection: Stone vs Player
            for (let i = stones.length - 1; i >= 0; i--) {
                // Use stone.radius for collision check as boss stones have different radius
                const currentStoneRadius = stones[i].radius || stoneRadius; // Default to normal stoneRadius
                if (
                    stones[i].x > playerX - currentStoneRadius &&
                    stones[i].x < playerX + playerWidth + currentStoneRadius &&
                    stones[i].y > playerY - currentStoneRadius &&
                    stones[i].y < playerY + playerHeight + currentStoneRadius
                ) {
                    // Collision!
                    if (isShieldActive) {
                        stones.splice(i, 1); // Stone is blocked by shield, remove it without damage
                        playSound('shield'); // Play shield sound on block
                    } else {
                        stones.splice(i, 1); // Remove stone, decrease life
                        lives--;
                        livesDisplay.textContent = `Vidas: ${lives}`;
                        playSound('hit'); // Play hit sound for player
                        if (lives <= 0) {
                            endGame("¡Te han golpeado demasiadas veces! ¡Fin del juego!");
                            return;
                        }
                    }
                    break; // Break as stone is handled
                }
            }

            // Collision detection: Player vs Velociraptor
            for (let i = velociraptors.length - 1; i >= 0; i--) {
                if (
                    playerX < velociraptors[i].x + velociraptorWidth &&
                    playerX + playerWidth > velociraptors[i].x &&
                    playerY < velociraptors[i].y + velociraptorHeight &&
                    playerY + playerHeight > velociraptors[i].y
                ) {
                    // Player collided with velociraptor!
                    velociraptors.splice(i, 1); // Remove velociraptor on collision
                    lives--;
                    livesDisplay.textContent = `Vidas: ${lives}`;
                    playSound('hit'); // Play hit sound for player
                    if (lives <= 0) {
                        endGame("¡Un velociraptor te ha alcanzado! ¡Fin del juego!");
                        return;
                    }
                    break; // Break as velociraptor is handled
                }
            }

            // Collision detection: Player vs Regular Giganotosaurus
            for (let i = giganotosauruses.length - 1; i >= 0; i--) {
                if (
                    playerX < giganotosauruses[i].x + giganotosaurusWidth &&
                    playerX + playerWidth > giganotosauruses[i].x &&
                    playerY < giganotosauruses[i].y + giganotosaurusHeight &&
                    playerY + playerHeight > giganotosauruses[i].y
                ) {
                    // Player collided with giganotosaurus!
                    giganotosauruses.splice(i, 1); // Remove giganotosaurus on collision
                    lives--;
                    livesDisplay.textContent = `Vidas: ${lives}`;
                    playSound('hit'); // Play hit sound for player
                    if (lives <= 0) {
                        endGame("¡Un Giganotosaurio te ha alcanzado! ¡Fin del juego!");
                        return;
                    }
                    break; // Break as giganotosaurus is handled
                }
            }

            // Collision detection: Player vs Power-up
            for (let i = powerUps.length - 1; i >= 0; i--) {
                if (
                    powerUps[i].x < playerX + playerWidth &&
                    powerUps[i].x + powerUpWidth > playerX &&
                    powerUps[i].y < playerY + playerHeight &&
                    powerUps[i].y + powerUpHeight > playerY
                ) {
                    // Player collected power-up!
                    const collectedPowerUp = powerUps.splice(i, 1)[0];
                    if (collectedPowerUp.type === 'multi-spear') {
                        hasMultiSpear = true; // Power-up is now permanent
                        // No specific sound for power-up for now
                    }
                    break; // Break as power-up is removed
                }
            }
        }

        // Draw all game elements
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear main canvas
            ctx.drawImage(backgroundCanvas, 0, 0); // Draw pre-rendered background

            drawPlayer();
            drawShield(); // Draw shield after player, so it appears around them

            spears.forEach(drawSpear);
            dinosaurs.forEach(drawDinosaur);
            velociraptors.forEach(drawVelociraptor); // Draw velociraptors
            giganotosauruses.forEach(drawGiganotosaurus); // Draw regular giganotosauruses
            if (bossActive) {
                drawBossGiganotosaurus(boss); // Draw the boss if active
            }
            stones.forEach(drawStone);
            powerUps.forEach(drawPowerUp); // Draw power-ups
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start game function
        function startGame() {
            score = 0;
            lives = 3;
            spears = [];
            dinosaurs = [];
            velociraptors = [];
            giganotosauruses = [];
            stones = [];
            powerUps = [];
            hasMultiSpear = false;
            isShieldActive = false;
            dinosaurSpawnRateIncreased = false; // Reset flag
            dinosaurSpawnInterval = 1000; // Reset to initial value (1 second)
            velociraptorSpawnInterval = 1000; // Ensure velociraptor spawn interval is reset (1 second)
            // Boss related resets
            bossActive = false;
            bossHealth = 0;
            boss = null;
            isBossFight = false;
            scoreDisplay.textContent = `Puntuación: ${score}`;
            livesDisplay.textContent = `Vidas: ${lives}`;
            messageBox.style.display = 'none';
            gameRunning = true;
            lastShotTime = Date.now(); // Initialize last shot time
            lastDinosaurSpawnTime = Date.now();
            lastVelociraptorSpawnTime = Date.now();
            lastGiganotosaurusSpawnTime = Date.now();
            gameLoop();

            // Start Tone.js audio context and music on user interaction (first game start or restart)
            // This is required by browser autoplay policies.
            if (Tone.context.state !== 'running') {
                Tone.start().then(() => {
                    Tone.Transport.start();
                });
            } else {
                Tone.Transport.start();
            }
        }

        // End game function
        function endGame(message) {
            gameRunning = false;
            messageText.textContent = message;
            messageBox.style.display = 'block';
            playSound('gameOver'); // Play game over sound when game ends
            Tone.Transport.stop(); // Stop background music on game over
        }

        // Event Listeners
        document.addEventListener('keydown', (e) => {
            if (e.key === 'a' || e.key === 'A') {
                playerMovingLeft = true;
            } else if (e.key === 'd' || e.key === 'D') {
                playerMovingRight = true;
            } else if (e.key === 'f' || e.key === 'F') {
                isShieldActive = !isShieldActive;
                playSound('shield'); // Play shield sound on toggle
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'a' || e.key === 'A') {
                playerMovingLeft = false;
            } else if (e.key === 'd' || e.key === 'D') {
                playerMovingRight = false;
            }
        });

        canvas.addEventListener('click', (e) => {
            const currentTime = Date.now();
            if (gameRunning && !isShieldActive && (currentTime - lastShotTime > fireRate)) {
                if (hasMultiSpear) {
                    spears.push({ x: playerX + playerWidth / 2 - spearWidth / 2, y: playerY - spearHeight });
                    spears.push({ x: playerX + playerWidth / 2 - spearWidth / 2 - 20, y: playerY - spearHeight });
                    spears.push({ x: playerX + playerWidth / 2 - spearWidth / 2 + 20, y: playerY - spearHeight });
                } else {
                    spears.push({
                        x: playerX + playerWidth / 2 - spearWidth / 2,
                        y: playerY - spearHeight
                    });
                }
                lastShotTime = currentTime; // Update last shot time
                playSound('shoot'); // Play shoot sound
            }
        });

        restartButton.addEventListener('click', startGame);

        // Mobile controls
        shootButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const currentTime = Date.now();
            if (gameRunning && !isShieldActive && (currentTime - lastShotTime > fireRate)) {
                if (hasMultiSpear) {
                    spears.push({ x: playerX + playerWidth / 2 - spearWidth / 2, y: playerY - spearHeight });
                    spears.push({ x: playerX + playerWidth / 2 - spearWidth / 2 - 20, y: playerY - spearHeight });
                    spears.push({ x: playerX + playerWidth / 2 - spearWidth / 2 + 20, y: playerY - spearHeight });
                } else {
                    spears.push({
                        x: playerX + playerWidth / 2 - spearWidth / 2,
                        y: playerY - spearHeight
                    });
                }
                lastShotTime = currentTime; // Update last shot time
                playSound('shoot'); // Play shoot sound
            }
        });
        leftButton.addEventListener('touchstart', () => { playerMovingLeft = true; });
        leftButton.addEventListener('touchend', () => { playerMovingLeft = false; });
        rightButton.addEventListener('touchstart', () => { playerMovingRight = true; });
        rightButton.addEventListener('touchend', () => { playerMovingRight = false; });
        shieldButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            // Toggle shield state on touch
            isShieldActive = !isShieldActive;
            playSound('shield'); // Play shield sound on toggle
        });

        // Initial start of the game
        window.onload = function() {
            initMusic(); // Initialize Tone.js components
            resizeCanvas(); // Set initial canvas dimensions, initialize background, and draw.
            startGame(); // Start the game loop.
        };
    </script>
</body>
</html>